import shutil

import numpy as np
import math
import glob
import matplotlib.pyplot as plt
import pandas as pd
import os
from datetime import datetime

def clearOutFolder(folder):
    if os.path.exists(folder):
        shutil.rmtree(folder)
    return

def checkDir(dir):
    if not os.path.exists(dir):
        os.makedirs(dir)
    return

def plotFromCSV(path, fileName, perfParam, increase = True, removeCollisions = True, plot = True):

    if perfParam in ['density', 'waitingTime', "flow", "speed"]:
        yLabel = perfParam.capitalize()
    else:
        yLabel = perfParam.capitalize()

    myDir = path + "/" + perfParam
    file = myDir + "/" + fileName + ".csv"
    checkDir(myDir)
    csvDF = pd.read_csv(file)

    eliteDF = pd.DataFrame(columns=csvDF.columns)

    # datetime object containing current date and time
    now = datetime.now()
    # dd/mm/YY H:M:S
    dt_string = now.strftime("%m_%d_%Y")
    plotFile = myDir + "/" + fileName + ".png"

    if removeCollisions == True:
        dropRows = csvDF[csvDF["collisions"] != 0].index
        csvDF.drop(dropRows, inplace=True)
    eliteIDX = None
    elite = None
    x = []
    y = []

    if perfParam=="combined":
        perfParam = "fitness"
    print(perfParam)
    for idx, row in csvDF.iterrows():
        if eliteIDX is None:
            eliteIDX = idx
            elite = csvDF[perfParam][eliteIDX]
        if increase == True:
            if csvDF[perfParam][eliteIDX] < row[perfParam]:
                eliteIDX = idx
                elite = csvDF[perfParam][eliteIDX]
        elif increase == False:
            if csvDF[perfParam][eliteIDX] > row[perfParam]:
                eliteIDX = idx
                elite = csvDF[perfParam][eliteIDX]
        # Append local elites to dataframe
        if idx == eliteIDX:
            # Add the iterations at which the new elite is found
            addColumns = pd.DataFrame(columns=["iterations"])
            addColumns.loc[0] = [idx]
            myRow = csvDF.loc[[eliteIDX]]
            myRow = myRow.reset_index(drop=True)
            addColumns = addColumns.reset_index(drop=True)
            newRow = pd.concat([myRow, addColumns], axis=1)
            eliteDF = eliteDF.append(newRow, ignore_index = True)


        # Next, append idx to x and performance param to y
        x.append(idx)
        if increase == False:
            y.append(elite)
        else:
            y.append(1/elite)
        iterations = idx
    '''
    print(eliteDF)
    print(x)
    print(y)
    '''
    # Save local elites to csv file
    eliteDF.to_csv(myDir + "/elite_" + fileName + ".csv", index=False)

    # Save final elite to file with added fitness type
    finalElitePath = path + "/final_elites.csv"
    finalElites = eliteDF.iloc[[len(eliteDF.index) - 1]]
    addColumns = pd.DataFrame(columns=["fitnessType"])
    addColumns.loc[0] = [perfParam]

    finalElites = finalElites.reset_index(drop=True)
    addColumns = addColumns.reset_index(drop=True)

    finalElites = pd.concat([finalElites, addColumns], axis=1)
    if not os.path.isfile(finalElitePath):
        finalElites.to_csv(path + "/final_elites.csv", index=False)
    else:
        finalElites.to_csv(path + "/final_elites.csv", mode='a', header=False, index=False)

    # Create plot of Genetic Algorithm
    plt.plot(x,y)
    plt.xlabel("Number of Simulations Generated by GA")
    plt.ylabel(yLabel)
    plt.title("Genetic Algorithm Convergence Using Fitness Parameter: " + yLabel)
    if plot == True:
        plt.savefig(plotFile, dpi = 500, bbox_inches='tight')
    plt.clf()
    plt.close()
    return

def GenerateStats(path, fileName, params, stat_data = {}):
    checkDir(path)
    file = path + "/" + fileName
    csvDF = pd.read_csv(file)
    dropRows = csvDF[csvDF["collisions"] != 0].index
    csvDF.drop(dropRows, inplace=True)
    for param in params:
        paramSTD = csvDF[param].std()
        paramMean = csvDF[param].mean()
        paramMin = csvDF[param].min()
        paramMax = csvDF[param].max()
        if param not in stat_data:
            stat_data[param] = []
            stat_data[param].append(paramMin)
            stat_data[param].append(paramMax)
            stat_data[param].append(paramMean)
            stat_data[param].append(paramSTD)
        else:
            if stat_data[param][0] > paramMin:
                stat_data[param][0] = paramMin
            if stat_data[param][1] < paramMax:
                stat_data[param][1] = paramMax
            if stat_data[param][2] < paramMean:
                stat_data[param][2] = paramMean
            if stat_data[param][3] < paramSTD:
                stat_data[param][3] = paramSTD
    return stat_data


'''
plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'flow_500', "flow", True)

plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'speed_1000', "speed", True)


plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'density_500', "density", False)

plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'speed_500', "speed", True)

plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    "z_score_combined",'combined', False)

plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    "waitingTime",'waitingTime', False)


plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'z_score_combined_1000IDM_1.0', "combined", False)
plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'z_score_combined_1000_IDM_0.75_tau_lower_limit', "combined", False)
plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'z_score_combined_1000_IDM_0.5_tau_lower_limit', "combined", False)
plotFromCSV('C:/Users/Matt/Sumo/Gville Test1/Traffic Analysis/GeneticAlgorithm',\
    'z_score_combined_1000_IDM_0.25_tau_lower_limit', "combined", False)
'''